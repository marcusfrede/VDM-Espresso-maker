class Grinder

types
public Bean :: id : nat
							 weight : nat1;
				

instance variables
math : MATH := new MATH();
io : IO := new IO();
beans : set of Bean := {};

operations

public Grinder: () ==> Grinder
Grinder() == (
 --let bean1 = mk_Bean(1) in
 --let bean2 = mk_Bean(1) in
 --let bean3 = mk_Bean(1) in
 --let bean3 = mk_Bean(math.rand(3)) in
 
 --beans := {bean1, bean2, bean3};
 
FillGrinder();
 
);
	--bean := new bean

public FillGrinder: () ==> ()
FillGrinder() == (
	dcl s : nat := 0; 
	
	while s <= 100 do 
		let b = mk_Bean(s, (math.rand(3) mod 3 + 1) ) in (		
		s := s + 1;
		beans := beans union {b}; );
);

public Grind: nat1 ==> ()
Grind(w) == (
	dcl tot : nat := 0; 
	for all s in set beans do
	if tot <= w
	then (tot := tot + s.weight; beans := beans \ {s})
	else return	
)
pre EnoughBeans(w); -- what if out off beans? error message!!!

pure EnoughBeans: nat1 ==> bool
EnoughBeans(w) == 
	return w <= RemaingBeanWeight();

pure RemaingBeanWeight: () ==> nat
RemaingBeanWeight() == (
	dcl tot : nat := 0; 
	for all s in set beans do
		tot := tot + s.weight;
	
	return tot;
);

end Grinder
