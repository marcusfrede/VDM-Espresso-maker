class Grinder

types
public Bean :: id : nat
							 weight : nat1;
				
public Beanseq :: weight : nat1;
				
instance variables
math : MATH := new MATH();
io : IO := new IO();
beansseq : seq of Beanseq := [];
beans : set of Bean := {};


operations



public Grinder: () ==> Grinder
Grinder() == (
 --let bean1 = mk_Bean(1) in
 --let bean2 = mk_Bean(1) in
 --let bean3 = mk_Bean(1) in
 --let bean3 = mk_Bean(math.rand(3)) in
 
 --beans := {bean1, bean2, bean3};
FillGrinder(100);
);


public FillGrinder: nat1 ==> ()
FillGrinder(upper) == 
	beans := {mk_Bean(x,(math.rand(3) mod 3 + 1)) | x in set{1,...,upper}}
pre upper <= 500
post card beans <= 500;
		
		
		
/*
public FillGrinder2: () ==> ()
FillGrinder2() ==
	for all s in set {1,...,100} do
		beansseq := beansseq ^ [mk_Beanseq(math.rand(3) mod 3 + 1)];
*/

public Grind: nat1 ==> ()
Grind(w) == (
	dcl tot : nat := 0; 
	for all s in set beans do
	if tot <= w
	then (tot := tot + s.weight; 
				beans := beans \ {s});
)
pre EnoughBeans(w); -- what if out off beans? error message!!!

pure EnoughBeans: nat1 ==> bool
EnoughBeans(w) == 
	return w <= RemaingBeanWeight();

pure RemaingBeanWeight: () ==> nat
RemaingBeanWeight() == (
	dcl tot : nat := 0; 
	for all s in set beans do
		tot := tot + s.weight;
	
	return tot;
);

end Grinder
