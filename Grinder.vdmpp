class Grinder

types

Bag = map nat1 to nat1; -- 1 er de 3 vægte(1,2,3). 2 svarer til mængden af bønner svarende til den vægt.
							 							
instance variables

beans : Bag := {|->};

functions

Remove : Bag * nat -> Bag
Remove (b, e) ==
  if e in set dom b
  then if b(e) = 1
       then  {e} <-: b
       else  b ++ {e |-> b(e) - 1}
  else b;

Select: Bag * nat -> Bag
Select(bag,weigth) ==
  if weigth = 0
  then bag
  else let b in set dom bag be st weigth = b or forall b1 in set dom bag & b >= b1
       in 
         Select(Remove(bag,b), (weigth - b) mod weigth)        
measure mselect;

mselect: Bag * nat -> nat
mselect(b, weight) == CalculateWeight(b) + weight;

Count : Bag * nat -> nat
Count (b, w) ==
  if w in set dom b
  then w * b(w)
  else 0;

CalculateWeight: Bag -> nat
CalculateWeight(b) ==
	Count(b,1) + Count(b,2) + Count(b,3);

operations


public FillGrinder: nat ==> ()
FillGrinder(n) == (
	IO`print("\nFilling Grinder with beans");
	
	beans := {x|-> MATH`rand(n) mod n + (n-10) | x in set{1,...,3}};
	
	IO`printf("\nGrinder filled with beans %1s %2s %3s", [beans(1), beans(2), beans(3)]);
);
--pre upper <= 500
--post card beans <= 500;


public Grind: nat1 ==> ()
Grind(weight) == (
	beans := Select(beans, weight);
	IO`print("\n*** Grinding");
)
pre EnoughBeans(weight); -- what if out off beans? error message!!!


pure public EnoughBeans: nat1 ==> bool
EnoughBeans(w) == 
	return w <= CalculateWeight(beans);

pure public RemaingBeanWeight: () ==> nat
RemaingBeanWeight() == 
	return CalculateWeight(beans);

end Grinder