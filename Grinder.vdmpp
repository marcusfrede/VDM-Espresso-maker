class Grinder

types
public Bean :: id : nat
							 weight : nat1;
				
public Beanq :: weight : nat1;
				
instance variables
math : MATH := new MATH();
io : IO := new IO();
beanss : seq of Beanq := [];
beans : set of Bean := {};

operations

public Grinder: () ==> Grinder
Grinder() == (
 --let bean1 = mk_Bean(1) in
 --let bean2 = mk_Bean(1) in
 --let bean3 = mk_Bean(1) in
 --let bean3 = mk_Bean(math.rand(3)) in
 
 --beans := {bean1, bean2, bean3};
 
FillGrinder();
);

public FillGrinder: () ==> ()
FillGrinder() == (
	for all s in set {1,...,100} do 
		beans := beans union {mk_Bean(s, (math.rand(3) mod 3 + 1)) }; 
);
/*
public FillGrinder2: () ==> ()
FillGrinder2() == (
	
	for all s in set {1,...,100} do
		beanss := beanss ^ [mk_Beanq(math.rand(3) mod 3 + 1)];
);
*/

public Grind: nat1 ==> ()
Grind(w) == (
	dcl tot : nat := 0; 
	for all s in set beans do
	if tot <= w
	then (tot := tot + s.weight; 
				beans := beans \ {s});
)
pre EnoughBeans(w); -- what if out off beans? error message!!!

pure EnoughBeans: nat1 ==> bool
EnoughBeans(w) == 
	return w <= RemaingBeanWeight();

pure RemaingBeanWeight: () ==> nat
RemaingBeanWeight() == (
	dcl tot : nat := 0; 
	for all s in set beans do
		tot := tot + s.weight;
	
	return tot;
);

end Grinder
