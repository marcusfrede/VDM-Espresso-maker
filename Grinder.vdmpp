class Grinder

types


public Bag = map nat1 to nat1;

-- 1 er de 3 vægte(1,2,3). 2 svarer til mængden af bønner svarende til den vægt.
							 							
instance variables


beans : Bag := {1 |-> 11, 2 |-> 51, 3 |-> 32};


functions


--measure mselect;


Count : Bag * nat -> nat
Count (b, w) ==
  if w in set dom b
  then w * b(w)
  else 0;

public CalculateWeight: Bag -> nat
CalculateWeight(b) ==
	let x = Count(b,1),
			y = Count(b,2), 
			z = Count(b,3)
	in 
		x + y + z;



mselect: Bag * nat -> nat
mselect(-, weight) == weight;



operations






Remove : Bag * nat ==> Bag
Remove (b, e) == (
  if e in set dom b
  then if b(e) = 1
       then beans := {e} <-: b
       else beans := b ++ {e |-> b(e) - 1}
  else beans := b;

return beans;
);

public
Select: Bag * nat ==> Bag
Select(bag,weigth) ==
  if weigth = 0
  then return {|->}
  else let b in set dom bag be st weigth = b or forall b1 in set dom bag & b >= b1
       in 
         Select(Remove(bag,b), (weigth - b) mod weigth);



















public FillGrinder: () ==> ()
FillGrinder() == (
	IO`print("\nFilling Grinder with beans");
	
--	bb := {x|-> MATH`rand(20) mod 20 + 10 | x in set{1,...,3}};
	
	
	IO`printf("\nGrinder filled with beans %1s %2s %3s", [beans(1), beans(2), beans(3)]);
);
--pre upper <= 500
--post card beans <= 500;


public Grind: nat1 ==> ()
Grind(w) == (
	let e = Select(beans,w)
	in
		IO`print("");
		
	IO`print("");

)
pre EnoughBeans(w); -- what if out off beans? error message!!!


pure EnoughBeans: nat1 ==> bool
EnoughBeans(w) == 
	return w <= CalculateWeight(beans);



pure public
RemaingBeanWeight: () ==> nat
RemaingBeanWeight() == (
 return CalculateWeight(beans)
);


end Grinder
