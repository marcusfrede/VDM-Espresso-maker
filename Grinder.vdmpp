class Grinder

types

public Bean :: id : nat
							 weight : nat1;

--public Weight = nat;	

public Bag = map nat1 to nat1;

-- 1 er de 3 vægte(1,2,3). 2 svarer til mængden af bønner svarende til den vægt.
							 							
instance variables

beans : set of Bean := {};
sbeans : seq of Bean := [];

bb : Bag := {1 |-> 10, 2 |-> 5, 3 |-> 3};


functions

mselect: Bag * nat -> nat
mselect(-, weight) == weight;

Remove : Bag * nat -> Bag
Remove (b, e) ==
  if e in set dom b
  then if b(e) = 1
       then {e} <-: b
       else b ++ {e |-> b(e) - 1}
  else b;


public
Select: Bag * nat -> Bag
Select(bag,weigth) ==
  if weigth = 0
  then {|->}
  else let b in set dom bag be st weigth = b or forall b1 in set dom bag & b >= b1
       in 
         Select(Remove(bag,b), (weigth - b) mod weigth);
--measure mselect;


Count : Bag * nat -> nat
Count (b, w) ==
  if w in set dom b
  then w * b(w)
  else 0;

public CalculateWeight: Bag -> nat
CalculateWeight(b) ==
	let x = Count(b,1),
			y = Count(b,2), 
			z = Count(b,3)
	in 
		x + y + z;





operations


public FillGrinder: () ==> ()
FillGrinder() == (
	IO`print("\nFilling Grinder with beans");
	
--	bb := {x|-> MATH`rand(20) mod 20 + 10 | x in set{1,...,3}};
	
	
	IO`printf("\nGrinder filled with beans %1s %2s %3s", [bb(1), bb(2), bb(3)]);
);
--pre upper <= 500
--post card beans <= 500;


public Grind: nat1 ==> ()
Grind(w) == (
	let e = Select(bb,w)
	in
		IO`print("");
		
	IO`print("");

)
pre EnoughBeans(w); -- what if out off beans? error message!!!


pure EnoughBeans: nat1 ==> bool
EnoughBeans(w) == 
	return w <= CalculateWeight(bb);



pure public
RemaingBeanWeight: () ==> nat
RemaingBeanWeight() == (
 return CalculateWeight(bb)
);


end Grinder
