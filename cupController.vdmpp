class CupController is subclass of GLOBAL

types
public Cup :: volume : CupSize;
public CupBag = map CupSize to seq of Cup;				
												
instance variables

cups : CupBag := {|->};

-- Hov her kunne da lige være en invariant der kiggede på om der var en forkert kop i det forkerte set.
-- Det kunne evt ske ved at der blev kigget på rng og dom passser sammen og at rng = 1 eller noget. 

maxCups  : nat := 0;

--inv CupSizeInv(cups, maxSmCups);
--inv CupSizeInv(cupsMd, maxMdCups);
--inv CupSizeInv(cupsLg, maxLgCups);


functions

public
FillCupStack: CupBag * CupSize * nat1 -> CupBag
FillCupStack(bag, cs, no) ==
	if cs not in set dom bag or len bag(cs) < no
	then FillCupStack(Add(bag,cs), cs, no)
	else bag;
		

Add : CupBag * CupSize -> CupBag
Add (bag, cs) ==
  if cs in set dom bag
  then bag ++ {cs |-> bag(cs) ^ [mk_Cup(cs)]}
  else bag ++ {cs |-> [mk_Cup(cs)]};

Append : CupBag * CupSize -> CupBag
Append (bag, cs) ==
  if cs in set dom bag
  then bag ++ {cs |-> bag(cs)}
  else bag;

Remove : CupBag * CupSize -> CupBag
Remove (bag, cs) ==
  if cs in set dom bag
  then if len bag(cs) = 1
       then {cs} <-: bag
       else bag ++ {cs |-> tl bag(cs)}
  else bag;

CupSizeInv: seq of Cup * nat -> bool
CupSizeInv(cups,maxCups) ==
 	len	cups <= maxCups;

operations

public FillCups: nat * nat * nat ==> ()
FillCups(small, medium, large) == (
	
	maxCups  := small;
	
	IO`printf("\nFilling cupstack with %1s Small, %2s Medium, %3s Large cups", [small, medium, large]);
	FillCupStacks(small);	
	IO`printf("\nCupstack filled with %1s Small, %2s Medium, %3s Large cups", RemainingCups());
);

public TakeCup: CupSize ==> ()
TakeCup(cs) == (

	if not CupAwailable(cs) then 
	(
		IO`printf("We are out of %1s cups", [cs]);
		CM`stateController.ErrorOccurred();
		return;
	);
	
	cups := 
			cases cs:
				<Small>,  <Single> -> Remove(cups, <Small>),
				<Medium>, <Double> -> Remove(cups,<Medium>),
				<Large>,  <Triple> -> Remove(cups,<Large>)
			end
);
	
public RemainingCups: () ==> seq of nat
RemainingCups() ==
	return [len cups(<Small>), len cups(<Medium>), len cups(<Large>)];

public CupAwailable: CupSize ==> bool
CupAwailable(cs) == 
	return
		cases cs:
			<Small>,  <Single> -> len cups(<Small>) > 0,
			<Medium>, <Double> -> len cups(<Medium>) > 0,
			<Large>,  <Triple> -> len cups(<Large>) > 0
		end;

private FillCupStacks: nat ==> ()
FillCupStacks(s) == (
	cups := Append(FillCupStack(cups ,<Small>,s),<Small>);
	cups := Append(FillCupStack(cups ,<Medium>,s),<Medium>);
	cups := Append(FillCupStack(cups ,<Large>,s),<Large>);
);
			
end CupController