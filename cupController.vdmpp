class CupController is subclass of GLOBAL

types
public Cup :: volume : CupSize;
public CupBag = map CupSize to seq of Cup;				
												
instance variables

cups : CupBag := {<Small>|->[], <Medium> |-> [], <Large> |-> []};

-- Hov her kunne da lige være en invariant der kiggede på om der var en forkert kop i det forkerte set.
-- Det kunne evt ske ved at der blev kigget på rng og dom passser sammen og at rng = 1 eller noget. 

maxCups  : nat := 0;

--inv WrongCupInv(cups);
--inv CupSizeInv(cups, maxCups);

functions

WrongCupInv: CupBag -> bool
WrongCupInv(cups) ==
  Exists(cups, <Small>) and
	Exists(cups, <Medium>) and
	Exists(cups, <Large>);
 	
CupSizeInv: CupBag * nat -> bool
CupSizeInv(cups,maxCups) ==
 	len	cups(<Small>) <= maxCups and
 	len	cups(<Medium>) <= maxCups and
 	len	cups(<Large>) <= maxCups; 	

public
FillCupStack: CupBag * CupSize * nat1 -> CupBag
FillCupStack(bag, cs, no) ==
	if cs not in set dom bag or len bag(cs) < no
	then FillCupStack(Add(bag,cs), cs, no)
	else bag;
--measure FillCupMeas;		

FillCupMeas: CupBag * CupSize * nat1 -> nat
FillCupMeas(bag, cs, n) == if cs not in set dom bag then 0 else len bag(cs) + 1;

Exists: CupBag * CupSize -> bool
Exists(bag, cs) ==
	cs in set dom bag;
	
Add : CupBag * CupSize -> CupBag
Add (bag, cs) ==
  if cs in set dom bag
  then bag ++ {cs |-> bag(cs) ^ [mk_Cup(cs)]}
  else bag ++ {cs |-> [mk_Cup(cs)]};

Append : CupBag * CupSize -> CupBag
Append (bag, cs) ==
  if cs in set dom bag
  then bag ++ {cs |-> bag(cs)}
  else bag;

Remove : CupBag * CupSize -> CupBag
Remove (bag, cs) ==
  if cs in set dom bag
  then if len bag(cs) = 1
       then {cs} <-: bag
       else bag ++ {cs |-> tl bag(cs)}
  else bag;

operations

public FillCups: nat ==> ()
FillCups(no) == (
	maxCups := no;
	FillCupStacks(no);	
	PrintRemainingCups();
);

public TakeCup: CupSize ==> ()
TakeCup(cs) == (

	if not CupAwailable(cs) 
	then 
			(
				IO`printf("We are out of %1s cups", [cs]);
				CM`stateController.ErrorOccurred();
				return;
			);
	
	cups := 
			cases cs:
				<Small>,  <Single> -> Remove(cups,<Small>),
				<Medium>, <Double> -> Remove(cups,<Medium>),
				<Large>,  <Triple> -> Remove(cups,<Large>)
			end;
	
		IO`print("\n*** Took cup");
			
);
	
public PrintRemainingCups: () ==> ()
PrintRemainingCups() == 
	for all c in set dom cups do
		IO`printf("\nCupstack contains %1s %2s cups", [len cups(c), c]);

pure public 
CupAwailable: CupSize ==> bool
CupAwailable(cs) == 
	return
		cases cs:
			<Small>,  <Single> -> Exists(cups,<Small>)  and len cups(<Small>) > 0,
			<Medium>, <Double> -> Exists(cups,<Medium>) and len cups(<Medium>) > 0,
			<Large>,  <Triple> -> Exists(cups,<Large>)  and len cups(<Large>) > 0
		end;
		
private FillCupStacks: nat ==> ()
FillCupStacks(s) == (
	cups := Append(FillCupStack(cups ,<Small>,s),<Small>);
	cups := Append(FillCupStack(cups ,<Medium>,s),<Medium>);
	cups := Append(FillCupStack(cups ,<Large>,s),<Large>);
);
			
end CupController