class CupController is subclass of GLOBAL

types
public Cup :: volume : CupSize;
public CupBag = map CupSize to seq of Cup;				
												
instance variables

cups : CupBag := {|->};

-- Hov her kunne da lige være en invariant der kiggede på om der var en forkert kop i det forkerte set.
-- Det kunne evt ske ved at der blev kigget på rng og dom passser sammen og at rng = 1 eller noget. 

maxCups  : nat := 0;

--inv WrongCupInv(cups);
--inv CupSizeInv(cups, maxCups);



--inv CupSizeInv(cupsMd, maxMdCups);
--inv CupSizeInv(cupsLg, maxLgCups);


functions

WrongCupInv: CupBag -> bool
WrongCupInv(cups) ==
 	card elems cups(<Small>) = 1 and
 	card elems cups(<Medium>) = 1 and
 	card elems cups(<Large>) = 1;
 	
CupSizeInv: CupBag * nat -> bool
CupSizeInv(cups,maxCups) ==
 	len	cups(<Small>) <= maxCups and
 	len	cups(<Medium>) <= maxCups and
 	len	cups(<Large>) <= maxCups; 	

public
FillCupStack: CupBag * CupSize * nat1 -> CupBag
FillCupStack(bag, cs, no) ==
	if cs not in set dom bag or len bag(cs) < no
	then FillCupStack(Add(bag,cs), cs, no)
	else bag;
--measure FillCupMeas;		

--FillCupMeas: CupBag * CupSize * nat1 -> CupBag
--FillCupMeas(bag, cs, n) == 2;


Add : CupBag * CupSize -> CupBag
Add (bag, cs) ==
  if cs in set dom bag
  then bag ++ {cs |-> bag(cs) ^ [mk_Cup(cs)]}
  else bag ++ {cs |-> [mk_Cup(cs)]};

Append : CupBag * CupSize -> CupBag
Append (bag, cs) ==
  if cs in set dom bag
  then bag ++ {cs |-> bag(cs)}
  else bag;

Remove : CupBag * CupSize -> CupBag
Remove (bag, cs) ==
  if cs in set dom bag
  then if len bag(cs) = 1
       then {cs} <-: bag
       else bag ++ {cs |-> tl bag(cs)}
  else bag;

operations

public FillCups: nat ==> ()
FillCups(no) == (
	
	maxCups := no;
	
	--beans := {x |-> y | y in set {<Small>, <Medium>, <Large>} };
	
	IO`printf("\nFilling cupstack with %1s Small, %2s Medium, %3s Large cups", [no, no, no]);
	FillCupStacks(no);	
	IO`printf("\nCupstack filled with %1s Small, %2s Medium, %3s Large cups", RemainingCups());
);

public TakeCup: CupSize ==> ()
TakeCup(cs) == (

	if not CupAwailable(cs) 
	then 
			(
				IO`printf("We are out of %1s cups", [cs]);
				return;
			);
	
	cups := 
			cases cs:
				<Small>,  <Single> -> Remove(cups, <Small>),
				<Medium>, <Double> -> Remove(cups,<Medium>),
				<Large>,  <Triple> -> Remove(cups,<Large>)
			end
);
	
public RemainingCups: () ==> seq of nat
RemainingCups() ==
	return [len cups(<Small>), len cups(<Medium>), len cups(<Large>)];

pure public 
CupAwailable: CupSize ==> bool
CupAwailable(cs) == 
	return
		cases cs:
			<Small>,  <Single> -> len cups(<Small>) > 0,
			<Medium>, <Double> -> len cups(<Medium>) > 0,
			<Large>,  <Triple> -> len cups(<Large>) > 0
		end;

private FillCupStacks: nat ==> ()
FillCupStacks(s) == (
	cups := Append(FillCupStack(cups ,<Small>,s),<Small>);
	cups := Append(FillCupStack(cups ,<Medium>,s),<Medium>);
	cups := Append(FillCupStack(cups ,<Large>,s),<Large>);
);
			
end CupController